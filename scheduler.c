#include "scheduler.h"
#ifndef __AVR_ATmega328P__
#define __AVR_ATmega328P__ 1
#endif

#ifndef F_CPU
#define F_CPU=16000000UL
#endif

#ifndef BAUD
#define BAUD 19200UL
#endif

#include "avr/io.h"
#include "usart.h"
#include "avr/interrupt.h"

#define TASK_NUM_MAX 4
#define TASK_STACK_SIZE 150

static unsigned char *stack_pointers[TASK_NUM_MAX] = {0};
unsigned char cur_registered_task_ptrs = 0;
unsigned char cur_task_ptr = 0;
unsigned int tmp_sp = 0;


unsigned int scheduler_get_stack_address(void);

void scheduler_init()
{
    unsigned int stack_pointer = scheduler_get_stack_address();
    for(unsigned char i = 0; i < TASK_NUM_MAX; i++){
        stack_pointers[i] = (unsigned char*) stack_pointer - 40  - i*TASK_STACK_SIZE;
    }
}

void print_addr(unsigned char * ptr){
    usart_transmit_char((unsigned char) ((unsigned int) ptr >> 8));
    usart_transmit_char((unsigned char) (unsigned int)ptr & 0xff);
}

void scheduler_register_task( void(*task)(void)) {
    unsigned char * stack_ptr = *(stack_pointers + cur_registered_task_ptrs);
    // Write task return address
    *stack_ptr-- = (unsigned char) task & 0xff;// Write lo8
    *stack_ptr-- = (unsigned char) ((unsigned int)task >> 8); // Write hi8
    for(int i = 0; i < 32;i++)
        *stack_ptr-- = 0;

    // Save sreg
    *stack_ptr-- = SREG;

    // Save stack pointer
    stack_pointers[cur_registered_task_ptrs] = stack_ptr;
//    print_addr(stack_ptr);

    // Increment task pointer
    cur_registered_task_ptrs++;




}

unsigned int scheduler_get_stack_address(void){
    asm volatile(
                "lds r24, 0x3d\n"
                "lds r25, 0x3e\n"
                );
}

void enable_wdt_interrupts(void){
    // Enable WDT interrupt every ~16 ms, this will be scheduler trigger time for round robin scheduling
        MCUCR |= (1<<WDRF);
        asm volatile(
                    "cli\n"
                    "wdr\n"
                    );
        WDTCSR |= (1<<WDCE) | (1<<WDE);
        WDTCSR  = (1<<WDIE);
        asm("sei");
}

void scheduler_enter()
{
    enable_wdt_interrupts();

    // Enter the first task
    asm volatile(
                // Load stack pointer
                "ldi zh, hi8(stack_pointers)\n"
                "ldi zl, lo8(stack_pointers)\n"

                // Load stack address of the first task
                "ld r26, Z+\n"
                "ld r27, Z+\n"

                // Jump 34 bytes which are used for storing registers on context switch
                "adiw x, 33\n"

                // Copy stack address to stack pointer
                "out 0x3d, r26\n"
                "out 0x3e, r27\n"

                // Return to task, will be generated by function
                );

}

void scheduler_switch_task(void){
    asm volatile(
                "push r0\n"
                "push r1\n"
                "push r2\n"
                "push r3\n"
                "push r4\n"
                "push r5\n"
                "push r6\n"
                "push r7\n"
                "push r8\n"
                "push r9\n"
                "push r10\n"
                "push r11\n"
                "push r12\n"
                "push r13\n"
                "push r14\n"
                "push r15\n"
                "push r16\n"
                "push r17\n"
                "push r18\n"
                "push r19\n"
                "push r20\n"
                "push r21\n"
                "push r22\n"
                "push r23\n"
                "push r24\n"
                "push r25\n"
                "push r26\n"
                "push r27\n"
                "push r28\n"
                "push r29\n"
                "push r30\n"
                "push r31\n"

                // Store sreg (33 pos)
                "in r1, 0x3F\n"
                "push r1\n"

                // Load current sp in X
                "in r26, 0x3D\n"
                "in r27, 0x3E\n"

                // Load pointer into which we will store
                "ldi zh, hi8(stack_pointers)\n"
                "ldi zl, lo8(stack_pointers)\n"

//                // Load current sp offset into z
                "ldi yh, hi8(cur_task_ptr)\n"
                "ldi yl, lo8(cur_task_ptr)\n "
                "ld r16, y\n"
                "ldi r17, 1\n"
                "ldi r18, 0\n"
                "calc_add_offset_to_z:\n"
                "adiw z, 2\n"
                "sub r16, r17\n"
                "cp r16, r18\n"
                "brne calc_add_offset_to_z\n"

                // Store current SP to stack_pointers[]
                "st Z+, r26\n"
                "st Z+, r27\n"

                "ld r16, y\n" // Load cur task index
                // Load number of reg tasks into r17
                "ldi yh, hi8(cur_registered_task_ptrs)\n"
                "ldi yl, lo8(cur_registered_task_ptrs)\n "
                "ld r17, y\n"


                // Add 1 to cur_task
                "ldi r18, 1\n"
                "add r16, r18\n"

                // If cur_task_ptr == cur_registered_task_ptrs
                "cp r16, r17\n"
                "brne skip_update_cur_task_idx\n"
                "ldi r16, 0\n" // Set cur idx to 0

                "skip_update_cur_task_idx:\n"
                "ldi yh, hi8(cur_task_ptr)\n"
                "ldi yl, lo8(cur_task_ptr)\n "
                "st y, r16\n" // store current idex to cur_task_ptr
                "ldi r18, 0\n"

                // Load pointer into which we will store
                "ldi zh, hi8(stack_pointers)\n"
                "ldi zl, lo8(stack_pointers)\n"

                "sub_addr:\n"
                "cp r18, r16\n"
                "breq load_stack_ptr_address\n"
                "adiw z, 2\n"
                "ldi r20, 1\n"
                "sub r16, r20\n"
                "jmp sub_addr\n"

                "load_stack_ptr_address:\n"
                "ld r26, Z+\n"
                "ld r27, Z+\n"

                "out 0x3d, r26\n"
                "out 0x3e, r27\n"

                "pop r1\n"
                "out 0x3F, r1\n"

                "pop r31\n"
                "pop r30\n"
                "pop r29\n"
                "pop r28\n"
                "pop r27\n"
                "pop r26\n"
                "pop r25\n"
                "pop r24\n"
                "pop r23\n"
                "pop r22\n"
                "pop r21\n"
                "pop r20\n"
                "pop r19\n"
                "pop r18\n"
                "pop r17\n"
                "pop r16\n"
                "pop r15\n"
                "pop r14\n"
                "pop r13\n"
                "pop r12\n"
                "pop r11\n"
                "pop r10\n"
                "pop r9\n"
                "pop r8\n"
                "pop r7\n"
                "pop r6\n"
                "pop r5\n"
                "pop r4\n"
                "pop r3\n"
                "pop r2\n"
                "pop r1\n"
                "pop r0\n"
                );

    //    WDTCSR |= (1<<WDIE);

    asm volatile ("reti");
}

ISR(WDT_vect, ISR_NAKED)
{
    asm("jmp scheduler_switch_task\n");

}
